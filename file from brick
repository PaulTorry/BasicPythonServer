robot@ev3dev:~/ev3_datalogging$ more distance.py
#!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor,
                                 InfraredSensor, UltrasonicSensor, GyroSensor)
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.hubs import EV3Brick
from pybricks.media.ev3dev import SoundFile, ImageFile
import socket
import time
import threading
import re



# This program requires LEGO EV3 MicroPython v2.0 or higher.
# Click "Open user guide" on the EV3 extension tab for more information.


# Create your objects here.
ev3 = EV3Brick()
us = UltrasonicSensor(Port.S1)
times = []
distances = []
collecting = 1
num = 0


# Write your program here.

addr = socket.getaddrinfo('0.0.0.0', 8080 )[0][-1]
s = socket.socket()
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind(addr)
s.listen(2)
print('Listening on', addr)
ev3.speaker.beep()


def get_html(html_name):
    with open(html_name, 'r') as file:
        html = file.read()
    return html


def send_html():
    print('sending html')
    response = get_html('index.html').encode()
    #print(response)
    cl.send(b'HTTP/1.0 200 OK\r\nContent-type: text/html\r\n\r\n')
    cl.send(response)
    #print('sent response')
    time.sleep(2)
    cl.close()
    #print('index.html sent')
    return

def send_data(x, xx):
    global num
    global times
    global distances
    #print('x:', x, type(x))
    #print('sending     data 71')
    collect_next_data()
    for i in range(int(x)):
        time.sleep(int(xx)/100)
        collect_next_data()
    #print('data collected')
    cl.send(b'HTTP/1.0 200 OK\r\nContent-type: text/html\r\n')
    cl.send(b'Access-Control-Allow-Origin: *\r\n\r\n')  # Allow all origins

    dataToSend = '{"a":'+ str(num) +', "b":"hi", "times":' + str(times) + ', "distances":' + str(distances) + '}\r\n\r\n
'
    cl.send(dataToSend.encode())
    num+= 1
    dd = cl.recv(1024)
    print(dd)
    cl.close()
    #print('data sent')
    return

def send_alldata():
    global num
    global times
    global distances
    cl.send(b'HTTP/1.0 200 OK\r\nContent-type: text/html\r\n')
    cl.send(b'Access-Control-Allow-Origin: *\r\n\r\n')  # Allow all origins
    dd = cl.recv(1024)   #thisline is vital to get the data to send !!!!
    print(dd)
    dataToSend = '{"a":'+ str(num) +', "b":"hi", "times":' + str(times) + ', "distances":' + str(distances) + '}\r\n\r\n
'
    cl.send(dataToSend.encode())
    cl.close()
    print('all data sent')
    return

def startrun():
    print('run started1')
    global num
    global times
    global distances
    global collecting
    times = []
    distances = []
    num = 0
    collecting = 200
    cl.send(b'HTTP/1.0 200 OK\r\nContent-type: text/html\r\n')
    cl.send(b'Access-Control-Allow-Origin: *\r\n\r\n')  # Allow all origins
    dataToSend = '{"a":'+ str(num) +', "b":"hi"}\r\n\r\n'
    cl.send(dataToSend.encode())
    dd = cl.recv(1024)
    cl.close()
    #print('run started2')
    return


def handle_client(cl, addr):
    global i
    global num
    global times
    global distances
    try:
        print('Client connected from', addr, cl)
        cl_file = cl.makefile('rwb', 0)

        while True:
            #cl.send(b'HTTP/1.0 200 OK\r\nContent-type: text/html\r\n\r\n')
            #cl.send("hi")
            line = cl_file.readline()
            if str(line).find('GET') > 0:
                print( "\n Recieved GET:  " + str(line))
                if str(line).find('GET / ') > 0:
                    print( " \n Send index.html " + str(line) + " \n        ")
                    send_html()
                if str(line).find('GET /data') > 0:
                    print( " \n Send Data      " + str(line) + " \n        ")
                    xx = re.findall(r'\d+',re.findall(r'x[\d]+y', str(line))[0])[0]
                    xxx = re.findall(r'\d+',re.findall(r'y[\d]+z', str(line))[0])[0]
                    print('xx:', xx, type(xx), 'xxx:', xxx, type(xxx))
                    send_data(xx, xxx)
                if str(line).find('GET /allData ') > 0:
                    print( " \n Send AllData      " + str(line) + " \n        ")
                    send_alldata()
                if str(line).find('GET /startRun') > 0:
                    print( " \n StartRun " + str(line) + " \n        ")
                    startrun()
            if not line or line == b'\r\n':
                break


    except OSError as e:
        cl.close()
        print('Connection closed')


def collect_next_data():
    global num
    global times
    global distances
    global collecting
    if collecting > 0:
        #ev3.speaker.beep()
        collecting -= 1
        distance = us.distance()
        #print('distance:', distance)
        times.append(time.time())
        distances.append(distance)
        num += 1

    return


while True:
    print('Waiting for a connection...')
    cl, addr = s.accept()
    handle_client(cl, addr)
